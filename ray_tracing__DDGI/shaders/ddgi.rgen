#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_GOOGLE_include_directive : enable
#include "random.glsl"
#include "raycommon.glsl"

layout(binding = 0, set = 0) uniform accelerationStructureEXT topLevelAS;

layout(binding = 1, set = 0, r11f_g11f_b10f) uniform image2D irradianceTex;
layout(binding = 2, set = 0, rg16)           uniform image2D visibilityTex;

layout(location = 0) rayPayloadEXT ddgiHitPayload prd;

layout(binding = 3, set = 0) uniform CameraProperties
{
  mat4 view;
  mat4 proj;
  mat4 viewInverse;
  mat4 projInverse;
}
cam;

#define MAX_SUBSAMPLES_PER_PROBE (6 * 16 * 16)

layout(binding = 4, set = 0) uniform DDGIProperties
{
  vec4  minPoint;
  vec4  maxPoint;
  vec4  probeDim;
  uint  subSamplesPerProbe;
  vec4  subSampleDirs       [MAX_SUBSAMPLES_PER_PROBE]; 
  uvec4 subSampleStoreOffset[MAX_SUBSAMPLES_PER_PROBE]; 
}
ddgiProps;

uint GetSubSampleID()
{
	return gl_LaunchIDEXT.x % ddgiProps.subSamplesPerProbe;
}

uvec3 GetProbeIdx()
{
	return uvec3(gl_LaunchIDEXT.xyz * vec3(1.0f / ddgiProps.subSamplesPerProbe, 1.0f, 1.0f));
}

vec3 GetProbeCenter(uvec3 probeIdx)
{
	return ddgiProps.minPoint.xyz + (probeIdx + 0.5f) * ddgiProps.probeDim.xyz;
}

vec3 GetSubSampleDirection(uint subSampleID)
{
	return ddgiProps.subSampleDirs[subSampleID].xyz;
}

ivec3 GetSubSampleStoreOffset(uint subSampleID)
{
	return ivec3(ddgiProps.subSampleStoreOffset[subSampleID].xyz);
}

layout(push_constant) uniform Constants
{
  vec4  clearColor;
  vec3  lightPosition;
  float lightIntensity;
  vec3  lightDirection;
  float lightSpotCutoff;
  float lightSpotOuterCutoff;
  int   lightType;
  int   frame;
}
pushC;

void main()
{
  prd.irradiance = vec4(1, 0, 0, 0);
  prd.depth      = 1;
  prd.depth2     = 1;
  
  uint  subSampleID = GetSubSampleID();
  uvec3 probeIdx    = GetProbeIdx();
  
  vec3 samplePos = GetProbeCenter(probeIdx);
  vec3 sampleDir = GetSubSampleDirection(subSampleID);
  ivec2 resultLoc = GetSubSampleStoreOffset(subSampleID).xy;

  prd.irradiance = vec4(0.5f * (sampleDir + 1.0f), 1.0f);
  
  uint  rayFlags = gl_RayFlagsNoneEXT;
  float tMin = 0.01f;
  float tMax = 10000.0f;

#if 0
  // shoot 4Kx4K rays
  samplePos = (ddgiProps.minPoint + ddgiProps.maxPoint).xyz / 2.0f - vec3(0, 300, 0);
  //sampleDir = normalize(vec3(-1.0f + 2.0f * gl_LaunchIDEXT.xy / vec2(gl_LaunchSizeEXT.xy), 1.0f));
	sampleDir = normalize(vec3(
        -1.0f,
		-1.0f + 2.0f * gl_LaunchIDEXT.y / float(gl_LaunchSizeEXT.y), 
		-1.0f + 2.0f * gl_LaunchIDEXT.x / float(gl_LaunchSizeEXT.x)));
  sampleDir.y *= -1.0f;
  resultLoc = ivec2(gl_LaunchIDEXT.xy);
#endif
  
  
  
  traceRayEXT(topLevelAS,     // acceleration structure
                  rayFlags,       // rayFlags
                  0xFF,           // cullMask
                  0,              // sbtRecordOffset
                  0,              // sbtRecordStride
                  0,              // missIndex
                  samplePos,      // ray origin
                  tMin,           // ray min range
                  sampleDir,      // ray direction
                  tMax,           // ray max range
                  0               // payload (location = 0)
			);

  imageStore(irradianceTex, resultLoc, prd.irradiance);
  imageStore(visibilityTex, resultLoc, vec4(prd.depth, prd.depth2, 0.0f, 0.0f));

  // Do accumulation over time
  //if(pushC.frame >= 0)
  //{
  //  float a         = 1.0f / float(pushC.frame + 1);
  //  vec3  old_color = imageLoad(irradianceTex, ivec2(gl_LaunchIDEXT.xy)).xyz;
  //  imageStore(irradianceTex, ivec2(gl_LaunchIDEXT.xy), vec4(mix(old_color, prd.irradiance.rgb, a), 1.0f));
  //  imageStore(visibilityTex, ivec2(gl_LaunchIDEXT.xy), vec4(prd.depth, prd.depth2, 0.0f, 0.0f));
  //}
  //else
  //{
  //  // First frame, replace the value in the buffer
  //  imageStore(irradianceTex, ivec2(gl_LaunchIDEXT.xy), prd.irradiance);
  //  imageStore(visibilityTex, ivec2(gl_LaunchIDEXT.xy), vec4(prd.depth, prd.depth2, 0.0f, 0.0f));
  //}
}
